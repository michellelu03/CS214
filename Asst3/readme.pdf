ds1576
ml1417
-------------------------------------------------------------------------------------------------
Socket Programming:
Server Set-Up:
-The first step to create a client/server model is to create a server socket since all client sockets have to connect to said server socket.
-We created a socket server by getting a socket descriptor from socket(). Then, we set up the socket with the SO_REUSEPORT socket option to allow multiple sockets on the same host to bind to the same port (intended to improve the performance of multithreaded network server applications). Once we have the socket descriptor, we bind it to the port that is given as an argument from the user. We listen for any incoming connections, and with this step and the step prior, we check if there are any errors that occur and send error if there are any. If successful, the next step is to accept any incoming clients and then create a thread to handle the action that the client requests (go to multithreading for more information on the threading aspect of the design).           
Client Set-Up:
-Since the client is also a socket, the steps are similar to the server set-up. To create a client socket, we first get a socket descriptor from socket(). Then, we connect the socket to the server using IP address/hostname and port number (should match the server port number) which are given by the user as arguments for the configure command. We check the status of the connection, and if the connection is not established, we will send an error to the user. This is usually of an invalid hostname/IP or different port number from the server.
Note: the server socket must be established (i.e. the executable ./WTFserver must be running prior to the establishment of client(s) (i.e. running the ./WTF executable)
-------------------------------------------------------------------------------------------------
Manifest:
-Since the manifest is the metadata for each project, we created a struct that would allow for easier manipulation. The manifest struct has the fields: int version, char* projectname, file** files which are the project's version number, name, and hash table of files respectively.
-The file struct has its own version number, name, digest, and file pointer to the next file. The pointer is used in creating the hash table of the files per project for worst case time complexity O(n) in search, insertion, and deletion of files. This is beneficial for changing files in the project.
-The digest of the file represents the file's contents that is used to compare to the contents of two files. We decided to use SHA-1 hash function to get the digest of a given file. The getDigest function takes in the file name as the parameter. Given the file name, we open that file and read that that file and utilize the provided SHA-1 initialization and update functions. Once the entire file is read, we finalize the SHA-1 hash.
-The hash table's hash function is the (ascii value of the file's name) mod number of entries
-Functions involving manifest: (their uses to be explained in procedure)
o   initManifest() mallocs space for a manifest struct
o   createManifestFile() creates a .Manifest file from a given manifest struct. The file contains the manifest version number followed by the files and their versions and digest
o   deleteFromManifest() deletes as given file from the manifest struct's hash table of files
o   updateManifest() updates the digest by calling getDigest on the file given that the file has been modified and increments the version number of the file
o   insertToManifest() inserts a file to the manifest's hash table of files
o   loadManifest() creates a manifest struct given a manifest file
o   freeManifest() frees the given manifest struct

Note: .Commit and .Update will be used along with .Manifest to keep track of the projects' progression.
-Every file whose live hash is different than the stored hash saved in the client's local .Manifest should have an entry written out to a .Commit with its file version number incremented.
-.Update file records all those changes that need to be made to bring up the client's files to the same version as the server's.
-------------------------------------------------------------------------------------------------
Procedure:

Client:
The client.c program deals with taking in commands from the user. The program expects either 3 or 4 arguments depending on the command. Prior to any action done, the user must configure to the server by providing its IP Address/hostname along with the port number of the server. This command will save the information in a .configure file, so the user does not have to have to reinput it with the commands following.
-Once configuration is completed, the user may do a number of actions by with the command lines ./WTF <action> <project name>. Therefore, the program expects 3 arguments in dealing with the following project commands: create, destroy, currentversion, checkout, update, upgrade, history, push, and commit. If the number of arguments is not 3 or argv[1] is not one of these commands, there is error. If the command is valid, then the program will initialize a network socket, using the initSocket() function. This function streamlines the program as it does not include repetitions of a socket initialization per each condition of command. The initSocket() function also checks for errors connecting to the server for when there is an invalid IP/hostname or port number.
-Once there is a successful creation of network socket connected with the server, the program then calls a respective function to execute the intended command. The functions are denoted by "client_<command>" and take the parameters of the project name (given as argv[2]) and the initialized network socket descriptor. Each function will write to the server a three letter code that indicates the command they are executing and will expect to receive confirmation of a digit from the server using read.
-Now we will examine the functions and their design:
Client_creat:
Sends the message CRT~#bytes~name to the server and indicates that the client has written to the server with a print statement. The server is expected to send back '0' to indicate that the project is not already in existence, so the program will create a directory named the project name and a .Manifest file in that directory. If the server indicates that the project already exists by sending back a nonzero number, then there will be a print statement that tells the user this.
Client_des:
Sends the message DES~#bytes~name to the server and expects either a 0 or nonzero digit message from the server. If the server sends back a '0', then the project does not exist on the server, and this is an error. If there is a nonzero digit received, then the project was destroyed. Either result will be indicated to the user via a print statement.
Client_ver:
Sends the message VER~#bytes~name to the server and expects a nonzero digit message from the server. If the received message is a '1', then the client will output a list of all files under the project name, along with their version number, as long as there is no error reading from the socket. If the receive message is a '2', then there was an error that no .Manifest was found for the project. Any other digit indicates that there was no project found with the given name.
Client_check:
The function will first check if the project exists on its side. If the project already exists locally on the client side, then there will be an error printed. If the project does not exist on the client side, then it will send a CHK~#bytes~name to the server. If the server sends back a '1', then the project was found on the server. The client will then read from the socket which the server has sent the project and will make the project directory on its side. This will be done with creating a .Manifest file and recreate it by initializing all the necessary directories and read each file's data. If the server sends back a '2', then there was not .Manifest file found for the given project. If server receives any other digit, then the server does not have the indicated project.
Client_update:
The function will first check if the project exists locally on the client side. If the project does not exist locally, then there is an error. If the project is found, then the function will read the projects directory and send the message UPD~#bytes~name to the server. If the server writes back a '1', then the client can receive the updated project from the server. The clients will then load up an initialized manifest struct with all the information from the server such as version number and the hash table of files. Then the client will load up the client-side version of the .Manifest file with manifest struct's information. There can be an error where the local manifest does not exist which will be indicated via print statement. If there is no errors thus far, then the client will compare the two manifest structs using clientDifference(), a function that compares the two manifests' fields like version number and contents, and if there are conflicts found, this will be indicated to the user. If the server writes back '2', then the .Manifest file was not found for the project on the server. If the server writes back a '3', then the .Manifest file on the server for the project is empty. If the server writes back any other digit, then the project does not exist on the server side. If the project is empty on the client side, this is also an error. All errors will be printed to the user.
Client_upgrade:
First the function will check if the project exists locally. If it does not, then there is an error since it cannot be upgraded if it does not exist. Otherwise the procedure is as follows. The function will check it .Conflict file exist, and if there are conflicts, then there will be a print statement to resolve the conflicts and update. If not, then the function will check for if .Update exists. If not, the user is told to run the update command on the project first. After these two checks are successful, then it will send UPG~#bytes~name to the server. If the server sends '1' back, then we know the project exists on the server, and we can read all files. For each file, we will check if it is up to date, and if all files are up to date then the program will return. Otherwise, the function loads up a manifest struct based off the local .Manifest file for the project. If the .Manifest file was empty, then this will be indicated as an error. Otherwise, to upgrade, the manifest struct will be manipulated using insert, delete, and update manifest struct functions. There will be a list that hold whether there is a modification, deletion, or addition using "M", "D", and "A" resprectively. Then the .Manifest file will be created based on the upgraded manifest struct using createManifestFile(). If the server sends back '2', then the .Manifest file for the project on the server side was not found. If the server sends back a '3', then the .Manifest file for the project on the server side was empty. If the server sends any other number, then the project does not exist on the server.
Client_commit:
First the function will check if the project exists. If the project does not exist locally, then this is an error which will be printed to the user. If the project does exist, then the function goes to check the project's .Conflict file. If there exists conflicts, this is an error. Otherwise, the function will go on to check .Update file, and if there exists pending updates, this is an error printed to the user. Once the project passes these checks, the client will write to the server socket COM~#bytes~name. If the server writes back a '1', then the function will load up the server's manifest to compare with the client's manifest using clientDifference(). If the server sends back a '2', '3' or other digit, then there are errors that indicate the server does not have a .Manifest for the project, the .Manifest file is empty, or the project does not exist on the servers respectively. Going back to the if there are no errors and the function calls clientDifference(), if there exists differences, then we remove <project>/.Commit file for the project and write to the server to not await a commit file. If there are no conflicts, then we tell the server than a commit will be coming and await for it. Commit is successful as the function will now send the commit. 
Client_push:
First the function will check if the project exists locally. If it does not, this is an error as there is nothing to commit. Then, the function checks for the existence of the .Commit file, and if there is no file found, the user will be prompted to run commit prior. Otherwise, the client will write to the server socket PUS~#bytes~#name. If the server writes back a '1', this indicated that the project exists on the server and the client can proceed. However, there can be errors if the server doesn't send a '1'. If the server writes back a '2', then there was no .Manifest for the project on the server. If the server writes back a '3', then there was only an empty .Manifest file found for the project. If the server writes back a '4', then the server does not have a corresponding .Commit, so the client will be prompted to run commit before pushing. If the server sends back any other number, then there was an error on the server, and the client is prompted to check the server's terminal where it is being run. To proceed with the commit process, the client will then load up commit from the server and hash the commit to check for duplicates. The function will check for if each file is an addition or has been modified. If so, the size of the message to the server will adjust accordingly, so the it knows how much to read. Then the client will send the hash of the file to the server. Then the client will once again go through the list of commits and will write the entire file to the server (if the file is indicated as added or modified). Afterwards, the client will receive a '0' if the push is success on the server side, and if it is, the client manifest will be modified. Modifications will be made to the digests of the files indicated with a 'M', and deletion/addition will also be executed to match the manifest. With a successful push, the manifest's version will be incremented on the manifest struct. The client will finally call the createManifestFile with the new manifest struct. 
Client_history:
First the function will write to the server a message HIS~#bytes~name to inidcate the command desired. Then it will receive from the server either a '1' or '0' if the project exists on the server. If the project exists, then the client will read the server's history of the project. Then the history of all operations performed on all successful pushes since the project's creation will be printed to the user as long as the server has no trouble in opening the .history. If the history isn't found on a server, then nothing is printed.
-There are other commands that require more parameters, so we also will be looking for command from the user that take the form ./WTF <action> <project name> <additional>. These commands are add, remove, and rollback (not including configure as we have already covered configure previously). If the number of arguments is not 4, argv[1] is not one of these commands, argv[2] and argv[3] are not valid, then there is error. Based on the command from argv[1], then a respective function is also called. This is similar to the previous functionality, but a socket is not necessary for add or remove since these actions take place locally. Rollback requires a network socket as it is accessing the server.
-Now we will examine these commands:
Add:
First checks if the project exists already. If it doesn't, then this is an error. Otherwise, the function checks if the project is empty, and if the project is empty, then then is an error. Otherwise, we check if the file exists. If not, this is an error. If the file does exist, then we access the project's .Manifest file. We check if the .Manifest is empty or has an existing file with the same name, which will indicate as an error and warning respectively. If the file passes these checks, then it is added to the project's .Manifest file successfully.
Rem:
First checks if the project exists already. If it doesn't, then this is an error. Otherwise, the function checks if the project is empty, and if the project is empty, then then is an error. Otherwise, we find the path to the file and the path to the .Manifest file of the project. We check if the .Manifest file exists for the project, and if it doesn't then this is an error. If this is not the case, then the function will load a manifest struct with the information provided from the .Manifest file. We will then delete the corresponding file from the manifest struct using deleteFromManifest. Once this is completed, we recreate the .Manifest file using the manifest struct using createManifestFile.
Client_rollback:
First the function will construct and send a message to the server in the format ROL~#bytes~name. The client will receive a message from the server indicating whether the project exists on the server. If it does not, this is an error and not much more can be done. Otherwise, the client will send the wanted version number to the server. The server will then indicate if the project was successfully rolledback to that version number on its side. Otherwise, the user is told that the version number is invalid for that project.

-------------------------------------------------------------------------------------------------
Procedure:

Server:
The server.c program maintains the server's repository which multiple clients are able to access. Running its executable ./WTFserver only requires the port number to listen and the command line should take format ./WTFserver <port number>. Therefore, the program expects for 2 arguments, so if this is not the case, then this is an error. If the port number is less than 1024, then this is invalid. Otherwise, the server will create a server socket (as discussed in the socket programming section). Once the server accepts a client, a thread is created to deal with that client, and the server goes back to accepting. This ensures that any client communication will not be in the same execution context that listens for new connections. For each thread, the server waits for the client to write the 3 letter code to indicate its wanted action from the server. The server then calls the function that is associated with the code. Some commands utilize the same function to streamline the code as some commands ask for the same information from the server side, but the client is the side with a separate execution. All the functions take the client socket file descriptor as a parameter and do send as needed to the client. This will be in the form of digits as indication of status of files/projects on the server and as well the contents necessary for the client to execute the command. The functions are denoted as "serv_<command>".
-   	The function utilizes the clientMessage function that takes in the client socket descriptor and then returns the project name that information is needed about.
-   	Now we will examine the functions and their design:
Serv_creat: for client code CRT
The function will check if the name is present on the server. If it already exists, the server will write back a '1'. Otherwise, the client will write back to the client a '0'. Then the server will create a directory with the project's name and create a .Manifest file.
Serv_del: for client code DES
The function will check if the name is present on the server. If it is not, then the server will write to the client a '0'. Otherwise, the server will send a '1' and recursively delete all the files of the project and then the project directory itself.
Serv_ver: for client codes VER, UPD
The function will look up the file if it exists on the server. If it is not, then the server will write back to the client a '0'. Otherwise, it will open the .Manifest file of the project (send '2' to client on error that it is not found) and load a manifest struct with the information from the file. If the .Manifest file is empty, then the server will send a '3' to indicate error. Otherwise, the server will write '1' to indicate success and then write the manifest struct's information to the client for the client to use accordingly.
Serv_check: for client codes CHK
The function will first check if the project exists, and if it does not, then writes to the client a '0' to indicate error. Then, it will load a manifest struct with all the information of the .Manifest file ('2' sent to client if the .Manifest doesn't exist). Otherwise, the server will write a '1' to the client to indicate success. It will then write the version to the client and then the files' information for the client to use. Then it will indicate that the files are being sent with a print statement and write the all the project's file (writeFile) to the client to use.
Serv_upgrade: for client code UPG
The function will first check if the project exists, and if it does not, then writes to the client a '0' to indicate error. Then, it will load a manifest struct with all the information of the .Manifest file ('2' sent to client if the .Manifest doesn't exist). If the .Manifest file exists, then the function will write the version number of the manifest and all the files of the project (using writeFile) for the client to use.
Serv_commit: for client code COM
The function will first check if the project exists on the server, and if if does not, then writes to the client a '0' to indicate error. Then, it will load a manifest struct with all the information of the .Manifest file ('2' sent to client if the .Manifest doesn't exist). After this is done, the function will initialize and load a manifest struct using the information from the .Manifest file. If the .Manifest file is empty, this is an error and a '3' is sent to the client to indicate it. Otherwise, the server sends a '1' to the client to indicate it has successfully located the manifest for the project. The function will then determine the size of the message to be sent about the manifest, so the client can read the according amount of bytes. Then, the function will write the entire manifest out by traversing through the manifest struct. Once the manifest is sent, the server will wait for a response from the client that indicates if the server should wait to receive a commit or not. Then it will receive the changes of the commit in the form a linked list and will record the commit in a file "<filename>/commit/<data>".
Serv_push: for client code PSH
The function will first check if the project exists or not. The server will write to the client this information, and will only continue execution if the project does exist. The server will then create a linked list of files based off of what is read from the client's .Commit file. If no file was receive, then this is an error. Otherwise, the server will check for an already existing .Commit on its side, and if it is not found, then this is an error. Then, the server will load up the commit and expire all other commits. Then the server will check if the manifest exists, if it not found it will send an error to the client. Otherwise, with the .Manifest file, the server will load up the manifest struct. There is also an error sent if the .Manifest file is empty. To proceed, the server will make a temporary directory to hold the old version of the project. If this is not possible, then this is an error that is sent to the client. But on success of the directory creation, a copy is put in it. Now, the server will traverse through the commit file. If a file is indicated with a 'A' for add, then the server will initilize a new file struct with all the file's information (digest, name) and create a path for it. If the file's path cannot be made, then is an error sent to the client to indicate a failure. If the file is indicated with an 'M' for modify, then a file struct is initialized with the newly modified information and it is inserted into the manifest struct's hash table of files after the previous version is deleted. The server will open the file, but if the file could not be created according to the path, then this is also a failure. The file is loaded up with new data. If the file is indicated by a 'D' for deletion, then the file's struct is deleted from the manifest and it is removed from the server. If there is error with the removal, then this is a failure. If there are any failures that occur throughout the process, a flag variable called failure will be set to '1'. After going through, if the failure flag is set, then the client will be sent a message for it. Otherwise, the old version of the project will be moved into .data, and the push will be successful as a new .Manifest file will be created from the updated manifest struct and the manifest's version is incremented. The client is told that the push is successful.
Serv_history: for client code HST
First the server will check if the project exists on its side. If not, this will be indicated to the client. Otherwise, the server will find the project's .history path and attempt to open it. If the file is unable to be opened, then the server will tell the client of the error. If the open is successful, then the server will tell the client it exists and then write the file over to the client
Serv_rollback: for client code ROL
First the server will check for the client if the project it wants to rollback exists on its side. If it does, the server will send a '1', and if not, it will send a '0' as a error. By sending the '1' to the client, this will indicate to the client to send the version number it wants to roll back to. Then the server will read the value from the client and will look for a path to that project's version in .data. If it is not able to open this path, then the server will write to the client this error. Otherwise, the server will copy to the current working directory and delete the directory recursively. Then it will rename the older version of the project and write to the server that the rollback is a success.
-------------------------------------------------------------------------------------------------
Multithreading:
-As the server should be able to handle multiple clients at a time, we implemented multithreading. The threads' creation occurs in the server.c file.
-We have a handle_connection function that deals with the client's message (which is the command they request from the server), and initially we implemented a top-bottom design for only a single client. The server accepts the client, and then the client descriptor is passed to the handle_connection, where the server figures out the command desired and executes it for the client and then sends back a confirmation to the client on whether it was successful or unsuccessful.
- This implementation of the connection handler makes multithreading simple. Upon accept of one client, we create a thread to deal with it, and then go back to accepting the next client... and so on. Since we don't know how many clients there will be, this process occurs within a while(1) loop, so sigint is required to terminate the server.
Note: We have created a signal handler for SIGINT, so we are able to nicely shut down all threads, close all sockets and file descriptors and free() all memory before allowing the process to terminate.
-The handle_connection function is a void*/void* function, so we can use pthread_create() to create a thread to deal with whichever client that is accepted.
 
-------------------------------------------------------------------------------------------------
Thread Synchronization:
-Since there can be multiple clients (i.e. multiple threads) on the server at once, the program will create a mutex for each project to control access to them.
-We made a mutex struct that has the fields: char* projectName, pthread_t* lock, and mutex* next. This allows us to have a global linked list of all the available projects on the server that can be accessed by all the threads. There is one mutex struct per project.
-The global linked list of mutexes is maintained as follows:
-With every creation of a project (client code CRT), the program will initialize and then add the mutex struct to the global linked list using initMutex() and mutex_creat().
-When destorying a project (client code DES), the program will remove the mutex struct associated with the project (based on mutex->name is equivalent to the project name) from the global linked list using mutex_del().
-When a thread needs to modify a project in any way, this is considered a critical section. The mutex for the project must be locked to prevent any other threads from accessing the project. Additionally, it needs to be unlocked immediately after modification to the project is completed to allow the next thread to access the newly modified project. This will ensure synchronization of the projects' contents.
-This will be accomplished utilizing the function getMutex() which takes in the char* for the project's name and returns a pointer to the corresponding mutex. Once the function has the mutex struct pointer, the program can lock the project, make modifcations, and then unlock it.
-An example: the wanted project to modify is called "test"
mutex* project = getMutex("test");
pthread_mutex_lock(project->lock);
----------
modification to project test
----------
pthread_mutex_unlock(project->lock);
-Upon exit, any mutexes ("projects left on the server") that still exist will be freed since the function freeMutexes() is in the atexit() signal. 
